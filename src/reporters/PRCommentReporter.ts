import * as github from '@actions/github';
import { TestResult } from '../types/TestResult';
import { CoverageData } from '../types/CoverageData';
import { CoverageReporter } from '../coverage/CoverageReporter';
import { logger } from '../utils/logger';

export class PRCommentReporter {
  private coverageReporter: CoverageReporter;

  constructor() {
    this.coverageReporter = new CoverageReporter();
  }

  async report(testResult: TestResult, coverage: CoverageData): Promise<void> {
    try {
      // Only comment on pull requests
      if (!github.context.payload.pull_request) {
        logger.debug('Not a pull request, skipping PR comment');
        return;
      }

      const token = process.env.GITHUB_TOKEN;
      if (!token) {
        logger.warning('GITHUB_TOKEN not found, skipping PR comment');
        return;
      }

      const octokit = github.getOctokit(token);
      const context = github.context;

      const commentBody = this.buildComment(testResult, coverage);

      // Check if we already have a comment
      const existingComment = await this.findExistingComment(octokit, context);

      if (existingComment) {
        // Update existing comment
        await octokit.rest.issues.updateComment({
          ...context.repo,
          comment_id: existingComment.id,
          body: commentBody,
        });
        logger.info('Updated existing PR comment');
      } else {
        // Create new comment
        await octokit.rest.issues.createComment({
          ...context.repo,
          issue_number: context.payload.pull_request!.number,
          body: commentBody,
        });
        logger.info('Created new PR comment');
      }
    } catch (error) {
      logger.warning(`Failed to post PR comment: ${error}`);
    }
  }

  private buildComment(testResult: TestResult, coverage: CoverageData): string {
    const statusEmoji = testResult.failed === 0 ? '✅' : '❌';

    let comment = `## ${statusEmoji} PHP Test Results\n\n`;

    // Test summary
    comment += '### Test Summary\n\n';
    comment += '| Metric | Value |\n';
    comment += '|--------|-------|\n';
    comment += `| Framework | ${testResult.framework} |\n`;
    comment += `| Total Tests | ${testResult.total} |\n`;
    comment += `| Passed | ✅ ${testResult.passed} |\n`;
    comment += `| Failed | ${testResult.failed > 0 ? `❌ ${testResult.failed}` : '0'} |\n`;

    if (testResult.skipped > 0) {
      comment += `| Skipped | ⚠️ ${testResult.skipped} |\n`;
    }

    comment += '\n';

    // Coverage summary
    comment += this.coverageReporter.formatSummary(coverage);

    // Add badge
    comment += '\n' + this.coverageReporter.formatCoverageBadge(coverage.summary.overall) + '\n';

    // Files with low coverage
    comment += this.coverageReporter.formatFileCoverage(coverage, 5);

    // Footer
    comment += '\n---\n';
    comment += '_Generated by [PHP Test Action](https://github.com/zeroseven/php-test-action)_\n';

    return comment;
  }

  private async findExistingComment(
    octokit: ReturnType<typeof github.getOctokit>,
    context: typeof github.context
  ) {
    try {
      const comments = await octokit.rest.issues.listComments({
        ...context.repo,
        issue_number: context.payload.pull_request!.number,
      });

      return comments.data.find(
        (comment) =>
          comment.user?.type === 'Bot' &&
          comment.body?.includes('PHP Test Results') &&
          comment.body?.includes('Generated by PHP Test Action')
      );
    } catch {
      return null;
    }
  }
}
